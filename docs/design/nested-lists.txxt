                Nested Lists Design Specification

NOTE: This is a proposed feature that has not been implemented yet.

This document outlines the design for implementing arbitrarily nested
todo lists in tdh.

1. Problem Analysis

    A simple, flat list is insufficient for organizing related tasks. Users 
    need the ability to break down larger items into smaller sub-tasks, 
    creating a natural hierarchy. The current system lacks the data model 
    and command structure to support this. The goal is to add this capability 
    while maintaining the speed and convenience of the existing interface.


2. Core Design: Data Model and Business Rules

    The implementation will be built on the following principles:

    Data Model:
    
        The Todo struct will be extended to support a recursive, parent-child 
        relationship. Each todo item will contain:
        
        • ID: A permanent, internal UUID.
        • ParentID: A UUID referencing the parent's ID. This is the key to 
          enabling efficient move operations. For top-level items, this will 
          be nil or a zero-value.
        • Position: A mutable, user-facing integer that is always relative 
          to its direct siblings.
        • Items: An array of child Todo structs, allowing for arbitrary nesting.

    Business Rules: A Course Correction

        Initial planning assumed a top-down, rigid propagation of status (e.g., completing a parent completes all children). Through analysis, we've identified a more robust, user-centric model that preserves information and better aligns with the tool's philosophy. The core principle is **preserving user intent**. The state of any given item is explicitly set by the user and is not altered by actions on its parent. Instead, the *behavior* of other commands is what changes.

        1.  **No Direct `delete` or `toggle`:** The `tdh` workflow for removing items is a two-step process: an item is first marked as `done`, and then a separate `cleanup` command removes all `done` items. This is a deliberate design choice that makes completion a non-destructive, reversible action. Consequently, there is no direct `delete` command. Similarly, the `toggle` command is being removed in favor of explicit `complete` and `reopen` commands, which are unambiguous and map directly to user intent.

        2.  **Behavioral Propagation (Top-Down Effect):** When a parent item is marked as `done`, the status of its children is **not** changed. Instead, commands that operate on the list treat the `done` parent as a "gate," stopping traversal down that branch.
            •   `tdh ls` (default view): Will not display `done` items or any of their descendants, regardless of the children's status. This matches the user's expectation: "If I'm done with a category, don't show me its contents."
            •   `tdh cleanup`: Will remove `done` items and all of their descendants. This also matches user expectation, cleaning up the entire branch at once.
            This approach is non-destructive. If the user reopens the parent, the children's original states are perfectly preserved.

        3.  **Bottom-Up Completion (Roll-Up Effect):** To provide a convenient quality-of-life improvement, a "bottom-up" rule will be implemented. When a user marks an item as `complete`, `tdh` will check the status of its siblings. If all siblings are now `complete`, the parent item will be automatically marked as `complete` as well. This recursively applies up the tree.

3. Internal API

    The internal APIs will be updated to handle the new hierarchical structure.

    Item Retrieval:
    
        A central, recursive function, `FindItemByPositionPath(collection, "1.2.1")`, will be the primary mechanism for locating items. It will parse the dot-notation string and traverse the `Items` arrays based on the `Position` field at each level.

    Transactional Integrity:
    
        All operations that modify the tree structure must be performed within a single, atomic `store.Update()` transaction. This guarantees that the data file is never left in a corrupted or inconsistent state.


4. User-Facing API (CLI)

    The command-line interface will be extended to manage the hierarchy, using dot-notation for addressing items.

    Addressing Items:
    
        Users will interact with items using a dot-separated path of `Position` numbers (e.g., `1`, `1.2`, `2.1.1`).

    `tdh add`:
    
        The `add` command will be enhanced with a `--parent` flag to create sub-items:
        
        • `tdh a "New top-level task"`: Adds an item to the root of the list.
        • `tdh a --parent 1.2 "New sub-task"`: Adds a new item as a child of the item at position 1.2.

    `tdh complete <positions...>`:
    
        A new command to mark one or more items as done.
        
        • `tdh complete 1.2`: Marks the item at 1.2 as `done`.
        • Triggers "Bottom-Up Completion" logic if applicable.

    `tdh reopen <positions...>`:
    
        A new command to mark one or more items as pending.
        
        • `tdh reopen 1.2`: Marks the item at 1.2 as `pending`.
        • This action only affects the specified item and does not propagate in any direction.

    `tdh ls`:
    
        The list command will be updated to handle the new hierarchy and respect the "Behavioral Propagation" rule.
        
        • `tdh ls`: Renders the full, indented list of all `pending` items. Traversal stops at any `done` item.
        • `tdh ls --depth 1`: (Future) Displays only the top-level items.

    `tdh cleanup`:
    
        The cleanup command will be updated to respect the "Behavioral Propagation" rule, deleting `done` items and all their descendants.