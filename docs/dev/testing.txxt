TESTING GUIDANCE

This project uses a test-driven approach with a focus on clear, fast, and reliable tests. We have a dedicated `testutil` package to make this easy. Please use it.

1. Unit Tests vs. Integration Tests

The most important rule is to distinguish between testing logic and testing I/O.

- UNIT TESTS (Preferred): Test business logic (e.g., in `pkg/tdh/commands.go`) without touching the file system. These are fast and reliable.
  - **ALWAYS** use `testutil.CreatePopulatedStore(t, ...)` or `testutil.CreateStoreWithSpecs(t, ...)` for these tests. They provide an in-memory store that requires no cleanup.

- INTEGRATION TESTS: These tests are for the storage layer (`pkg/tdh/store`) itself. They are the ONLY tests that should interact with the file system.
  - Use `t.TempDir()` to create temporary directories that are cleaned up automatically.

2. Use Setup Helpers for Test Arrangement

Do not manually create stores or populate them in your tests. Use the helpers to arrange your test state in a single, readable line.

- `CreatePopulatedStore(t, "Task 1", "Task 2")`: Quickly create a store with pending todos.
- `CreateStoreWithSpecs(t, []testutil.TodoSpec{...})`: Create todos with specific statuses (e.g., `models.StatusDone`).

3. Use Custom Assertions for Verification

Do not write manual `for` loops or complex checks in your tests. Use the domain-specific assertions to make your tests clear and your failure messages helpful.

Key Assertions:
- `AssertTodoInList(t, todos, "Expected text")`
- `AssertTodoNotInList(t, todos, "Unexpected text")`
- `AssertTodoCount(t, result, 10, 3)` (Checks total and done counts)
- `AssertTodoHasStatus(t, todo, models.StatusDone)`

For a full list of helpers, see the `pkg/tdh/testutil` package.

Example of a Good Test:

func TestCleanCommand(t *testing.T) {
    // 1. ARRANGE: Use a setup helper.
    specs := []testutil.TodoSpec{
        {Text: "Pending Item", Done: false},
        {Text: "Done Item",    Done: true},
    }
    store, _ := testutil.CreateStoreWithSpecs(t, specs)

    // 2. ACT: Call the function being tested.
    cleanResult, err := tdh.Clean(CleanOptions{CollectionPath: store.Path()})
    require.NoError(t, err)

    // 3. ASSERT: Use custom assertions.
    assert.Equal(t, 1, cleanResult.RemovedCount)
    
    // And verify the final state.
    finalResult, _ := store.Find(store.Query{})
    testutil.AssertTodoCount(t, finalResult, 1, 0)
    testutil.AssertTodoNotInList(t, finalResult.Todos, "Done Item")
}
