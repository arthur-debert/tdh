# Golang CLI Template Configuration for Copier

# Module description for dynamic listing
module_description: "Complete Go CLI application with Cobra, build scripts, and GitHub Actions"

# Template metadata - only process .jinja files
_templates_suffix: ".jinja"
_envops:
  block_start_string: "{%"
  block_end_string: "%}"
  variable_start_string: "{{"
  variable_end_string: "}}"

# Store answers file in .copier directory
_answers_file: ".copier/.copier-answers.golang-cli.yml"

# Exclude files that shouldn't be copied to the destination
_exclude:
  - "**/*.bak"
  - ".goreleaser.yml.template"
  - "{% if not use_version_package %}internal{% endif %}"

# Questions specific to Golang CLI projects
project_name:
  type: str
  help: What is your project name?
  default: "{{ _copier_conf.dst_path | basename | replace('-', ' ') | replace('_', ' ') | title }}"

package_name:
  type: str
  help: What is the package/binary name?
  default: "{% set dir_name = _copier_conf.dst_path | basename %}{% if dir_name == '.' %}my-cli{% else %}{{ dir_name }}{% endif %}"

github_user:
  type: str
  help: What is your GitHub username?
  default: "arthur-debert"

author_name:
  type: str
  help: What is your full name?
  default: "Arthur Debert"

author_email:
  type: str
  help: What is your email address?
  default: "arthur@debert.xyz"

description:
  type: str
  help: Brief description of your CLI tool
  default: "Description of your CLI tool"

license:
  type: str
  help: What license to use?
  choices:
    - MIT
    - Apache-2.0
    - GPL-3.0
    - BSD-3-Clause
  default: MIT

go_version:
  type: str
  help: Go version to use
  default: "1.23"

year:
  type: int
  help: Copyright year
  default: "{{ 2024 }}"

use_version_package:
  type: bool
  help: Use a dedicated version package (internal/version) instead of main package vars?
  default: true

# Post-generation tasks for Golang CLI
_tasks:
  - command: |
      # Setting up standard project structure
      # Create standard directories
      mkdir -p local/prompts docs/dev

      # Create .gitkeep for prompts directory
      cat > local/prompts/.gitkeep << 'EOF'
      # This file ensures the prompts directory is tracked by git
      # The local/ directory is for development-specific files and should be in .gitignore  
      # This prompts/ subdirectory can contain AI prompts, templates, or other local development resources
      EOF

      # Create development documentation
      cat > docs/dev/README.md << 'EOF'
      # Development Documentation

      This directory contains development-specific documentation for the {{ package_name }} project.

      ## Structure

      - `README.md` - This file, overview of development documentation
      - Additional development guides and documentation can be added here

      ## Placeholder

      This is a placeholder file. Add your development documentation, guides, and notes here as the project grows.

      ## Common Topics

      Consider documenting:
      - Development setup and environment
      - Architecture decisions and patterns
      - Debugging guides
      - Performance considerations
      - Deployment procedures
      - Contributing guidelines for developers
      EOF

  - command: |
      # Creating universal .envrc file
      cat > .envrc << 'EOF'
      #!/bin/bash

      # Universal project environment variables
      export PROJECT_ROOT="$PWD"
      export PKG_NAME="{{ package_name }}"
      export GH_USER="{{ github_user }}"
      export GH_URL="https://github.com/{{ github_user }}/{{ package_name }}"

      # Derived URLs
      export GH_REPO="{{ github_user }}/{{ package_name }}"
      export GH_CLONE_URL="git@github.com:{{ github_user }}/{{ package_name }}.git"

      # Add project's bin directory to PATH
      export PATH="$PROJECT_ROOT/bin:$PATH"

      # Go-specific environment
      export GOPATH="${GOPATH:-$HOME/go}"
      export PATH="$PATH:$GOPATH/bin"

      # Development tools
      if command -v direnv >/dev/null 2>&1; then
          echo "âœ… direnv loaded for {{ package_name }}"
      else
          echo "ðŸ’¡ Install direnv for automatic environment loading: brew install direnv"
      fi
      EOF

      chmod +x .envrc

  - command: |
      # Rename cmd directory from placeholder to actual package name
      # First, try to determine the actual package name from the directory if needed
      PKG_NAME="{{ package_name }}"
      
      # If package name is still the default, use the directory name
      if [ "$PKG_NAME" = "my-cli" ] || [ "$PKG_NAME" = "my-awesome-cli" ]; then
          DIR_NAME=$(basename "$PWD")
          if [ "$DIR_NAME" != "." ] && [ -n "$DIR_NAME" ]; then
              PKG_NAME="$DIR_NAME"
              echo "Using directory name as package name: $PKG_NAME"
          fi
      fi
      
      if [ -d "cmd/__PACKAGE_NAME_PLACEHOLDER__" ]; then
          mv "cmd/__PACKAGE_NAME_PLACEHOLDER__" "cmd/$PKG_NAME"
          
          # Also update go.mod with the correct package name
          if [ -f "go.mod" ]; then
              sed -i.bak "s|github.com/{{ github_user }}/{{ package_name }}|github.com/{{ github_user }}/$PKG_NAME|g" go.mod
              rm -f go.mod.bak
          fi
          
          # Update imports in Go files
          find . -name "*.go" -type f -exec sed -i.bak "s|github.com/{{ github_user }}/{{ package_name }}|github.com/{{ github_user }}/$PKG_NAME|g" {} \;
          find . -name "*.go.bak" -type f -delete
      fi
    description: "Renaming template directories to use actual package name"

  - command: |
      # Make all scripts executable
      chmod +x scripts/*
    description: "Making scripts executable"
    
  - command: |
      # Update build-all script references if needed
      if [ -f "scripts/build-all" ]; then
          # Determine package name
          PKG_NAME="{{ package_name }}"
          if [ "$PKG_NAME" = "my-cli" ] || [ "$PKG_NAME" = "my-awesome-cli" ]; then
              DIR_NAME=$(basename "$PWD")
              if [ "$DIR_NAME" != "." ] && [ -n "$DIR_NAME" ]; then
                  PKG_NAME="$DIR_NAME"
                  sed -i.bak "s|{{ package_name }}|$PKG_NAME|g" scripts/build-all
                  rm -f scripts/build-all.bak
              fi
          fi
      fi
    description: "Updating build-all script references"
    
  - command: |
      # Update package name references if using directory name
      PKG_NAME="{{ package_name }}"
      
      # If package name is still the default, use the directory name
      if [ "$PKG_NAME" = "my-cli" ] || [ "$PKG_NAME" = "my-awesome-cli" ]; then
          DIR_NAME=$(basename "$PWD")
          if [ "$DIR_NAME" != "." ] && [ -n "$DIR_NAME" ]; then
              PKG_NAME="$DIR_NAME"
              
              # Update .envrc
              if [ -f ".envrc" ]; then
                  sed -i.bak "s|PKG_NAME=\"{{ package_name }}\"|PKG_NAME=\"$PKG_NAME\"|g" .envrc
                  sed -i.bak "s|/{{ package_name }}\"|/$PKG_NAME\"|g" .envrc
                  sed -i.bak "s|/{{ package_name }}.git|/$PKG_NAME.git|g" .envrc
                  sed -i.bak "s| for {{ package_name }}| for $PKG_NAME|g" .envrc
                  rm -f .envrc.bak
              fi
              
              # Update binary name in .gitignore
              if [ -f ".gitignore" ]; then
                  sed -i.bak "s|^/{{ package_name }}$|/$PKG_NAME|g" .gitignore
                  sed -i.bak "s|^{{ package_name }}-|$PKG_NAME-|g" .gitignore
                  rm -f .gitignore.bak
              fi
              
              # Update README if needed
              if [ -f "README.md" ]; then
                  sed -i.bak "s|{{ package_name }}|$PKG_NAME|g" README.md
                  rm -f README.md.bak
              fi
              
              # Update .goreleaser.yml
              if [ -f ".goreleaser.yml" ]; then
                  sed -i.bak "s|binary: {{ package_name }}|binary: $PKG_NAME|g" .goreleaser.yml
                  rm -f .goreleaser.yml.bak
              fi
              
              # Update build script
              if [ -f "scripts/build" ]; then
                  sed -i.bak "s|Building {{ package_name }}|Building $PKG_NAME|g" scripts/build
                  sed -i.bak "s|my-cli|$PKG_NAME|g" scripts/build
                  rm -f scripts/build.bak
              fi
              
              # Update other scripts that reference the package
              for script in scripts/test scripts/lint scripts/gen-completion scripts/gen-manpage; do
                  if [ -f "$script" ]; then
                      sed -i.bak "s|{{ package_name }}|$PKG_NAME|g" "$script"
                      sed -i.bak "s|my-cli|$PKG_NAME|g" "$script"
                      rm -f "${script}.bak"
                  fi
              done
          fi
      fi
    description: "Updating package name references based on directory"
  
  - command: |
      # Append Go-specific entries to .gitignore
      touch .gitignore  # Ensure file exists
      
      # Determine package name
      PKG_NAME="{{ package_name }}"
      if [ "$PKG_NAME" = "my-cli" ] || [ "$PKG_NAME" = "my-awesome-cli" ]; then
          DIR_NAME=$(basename "$PWD")
          if [ "$DIR_NAME" != "." ] && [ -n "$DIR_NAME" ]; then
              PKG_NAME="$DIR_NAME"
          fi
      fi
      
      cat >> .gitignore << EOF
      
      # Go binaries and build artifacts
      *.exe
      *.exe~
      *.dll
      *.so
      *.dylib
      
      # Test binary, built with go test -c
      *.test
      
      # Output of the go coverage tool
      *.out
      cover.html
      coverage.txt
      
      # Go workspace file
      go.work
      go.work.sum
      
      # Binary output
      /$PKG_NAME
      $PKG_NAME-*
      
      # Build directories
      /bin/
      /dist/
      /completions/
      /man/
      
      # GoReleaser
      dist/
      
      # Dependency directories (uncomment if needed)
      # vendor/
      
      # Go mod cache
      /go/pkg/mod/
      EOF
      
      # Remove duplicates while preserving order
      awk '!seen[$0]++' .gitignore > .gitignore.tmp && mv .gitignore.tmp .gitignore
    description: "Adding Go entries to .gitignore"

  - command: |
      # Initializing git repository
      if [ ! -d ".git" ]; then
          git init
      fi
      git add .
      git commit -m "Initial commit for {{ package_name }}" || echo "Git commit skipped"

  - command: |
      # Installing pre-commit hooks
      if [ -f "scripts/pre-commit" ]; then
          ./scripts/pre-commit install || echo "Pre-commit hook installation failed"
      fi

  - command: |
      # Setting up direnv
      direnv allow || echo "direnv allow failed - install direnv with: brew install direnv"

  - command: |
      # Installing Go dependencies
      go mod tidy || echo "Go mod tidy failed"

  - command: |
      # Testing the build
      ./scripts/build || echo "Build test failed"
      
  - command: |
      # Create additional directories
      mkdir -p dist tmp .copier
      
      # Move copier-related files to .copier directory
      if [ -f "copier.yml" ]; then
          mv copier.yml .copier/ 2>/dev/null || true
      fi
      
      # Move template usage to docs
      if [ -f "TEMPLATE_USAGE.md" ]; then
          mkdir -p docs
          mv TEMPLATE_USAGE.md docs/ 2>/dev/null || true
      fi
      
      # Clean up the .copier-answers file from root if it exists
      if [ -f ".copier-answers.yml.jinja" ]; then
          rm -f .copier-answers.yml.jinja
      fi
      
      echo "âœ… Project structure organized"
